f(x, y)
expr(!!f(x, y))
expr(!!f(x, y)) == 3
expr(!!f(x, y) + 3)
expr(!!f(x, y) + 3) == 6
eval(expr(!!f(x, y) + 3)) == 6
expr(!!expr(f(x, y)) + 3) == 6
expr(!!expr(f(x, y)) + 3)
## unquoting a function
## only challenge expr(!!f(x, y)) unquotes the result of f(x, y) so you need an
## extra pair of parentheses
f <- expr(foo)
expr((!!f)(x, y))
## equivalent to
call2(f, expr(x), expr(y))
expr(foo(x, y))
f <- expr(foo)
expr(!!f(x, y))
expr((!!f)(x, y))
## unquoting missing arguments
arg <- rlang::missing_arg()
expr(foo(!!arg, !!arg))
#> Error in enexpr(expr) : object 'arg' not found
expr(foo(!!maybe_missing(arg)))
## unquoting many args
## !!! takes a list of expressions and inserts them at the location of the !!!
xs <- exprs(1, a, -b)
ys <- set_names(xs, c("a", "b", "c"))
expr(f(!!!ys, d = 4))
?set_names
## unquoting many args
## !!! takes a list of expressions and inserts them at the location of the !!!
xs <- exprs(1, a, -b)
ys <- setNames(xs, c("a", "b", "c"))
expr(f(!!!ys, d = 4))
deparse("")
deparse(expr(1 + 1))
deparse(expr(1 + 1)) %>% substitute()
library(tidyverse)
deparse(expr(1 + 1)) %>% substitute()
deparse(expr(1 + 1)) %>% substitute()
deparse(expr(1 + 1))
substitute(!!deparse(expr(1 + 1)))
## non-quoting
## one baseR funciton that implements quasiquotation: bquote()
## uses .() for unquoting
xyz <- bquote((x + y + z))
rlang::is_expression(xyz)
bquote(-.(xyz) / 2)
zyx <- rlang::expr(x + y + z)
bquote(-.(zyx) / 2)
## baseR uses non-quoting techniques, i.e. selectively turns off quoting rather
## than using unquoting
## 4 basic forms of that concept: 1.
`$`(mtcars, cyl)
?with
df <- data.frame(x = 1, y = 2)
with(df, x + y)
df <- list(x = 1, y = 2)
with(df, x + y)
df <- env(x = 1, y = 2)
df$x
with(df, x + y)
rm(df)
rm(list = ls())
?rm
pkg <- "rlang"
library(pkg)
library(pkg)
library(pkg, character.only = TRUE)
## 4. quoting if evaluation fails
help(var)
var <- "mean"
help(var)
var <- 10
help(var)
?match.fun
test <- match.fun("rlang::expr")
test <- match.fun("expr")
test(hello)
rm(list = ls())
sink
power <- function(exponent)
{
function(x, exponent)
{
x^exponent
}
}
power(0.5)
power(0.5)(9)
power <- function(exponent)
{
function(x)
{
x^exponent
}
}
power(0.5)(9)
power <- function(exponent) {
new_function(
exprs(x = ),
expr({
x ^ !!exponent
}),
caller_env()
)
}
power(0.5)
power(0.5)(9)
power <- function(exponent)
{
function(x)
{
x^exponent
}
}
power(0.5)
power <- function(exponent) {
new_function(
exprs(x = ),
expr({
x ^ !!exponent
}),
caller_env()
)
}
power(0.5)
new_function
?subset
subset(iris, subset = )
iris
head(iris)
subset(iris, subset = Species == setosa, select = Sepal.Width)
subset(iris, subset = Species == "setosa", select = Sepal.Width)
subset(iris, subset = Species == "setosa", select = Sepal.Width, Species)
subset(iris, subset = Species == "setosa", select = c(Species, Sepal.Width))
select(iris, "Species")
test <- "test"
test <- "TEST"
.(test)
expr(.(test))
## unquoting many args
## !!! takes a list of expressions and inserts them at the location of the !!!
xs <- exprs(1, a, -b)
library(rlang)
## unquoting many args
## !!! takes a list of expressions and inserts them at the location of the !!!
xs <- exprs(1, a, -b)
ys <- set_names(xs, c("a", "b", "c"))
expr(f(!!!ys, d = 4))
ys
## @daniehei if a function quotes an argument, that is, you can specify the arg as
## source without quoting. unquoting = selectively evaluate code!
f <- function(x)
{
expr(!!x + y)
}
f(3)
## @daniehei if a function quotes an argument, that is, you can specify the arg as
## source without quoting. unquoting = selectively evaluate code!
f <- function(x)
{
z <- enexpr(x)
expr(!!z + y)
}
f(3)
## @daniehei if a function quotes an argument, that is, you can specify the arg as
## source without quoting. unquoting = selectively evaluate code!
f <- function(x)
{
expr(!!z + y)
}
f(3)
dplyr::bind_rows(!!!dfs)
## ... (dot-dot-dot)
## read again 19 Quasiquotation Outline
dfs <- list(
a = data.frame(x = 1, y = 2),
b = data.frame(x = 3, y = 4)
)
dplyr::bind_rows(!!!dfs)
rbind(!!!dfs)
rbind(expr(!!!dfs))
expr(!!!dfs)
exprs(!!!dfs)
rbind(exprs(!!!dfs))
?rbind
rbind(exprs(!!!dfs), deparse.level = 1)
rbind(exprs(!!!dfs), deparse.level = 2)
rbind2 <- function(list_of_dfs)
{
ldfs <- enexprs(list_of_dfs)
rdf <- purrr::map_df(ldfs, rbind)
rdf
}
rbind2(!!!dfs)
ddfs
dfs
rbind2 <- function(...)
{
ldfs <- rlang::list2(...)
rdf <- purrr::map_df(ldfs, rbind)
rdf
}
rbind2(!!!dfs)
var <- "x"
val <- c(1, 2, 3)
tibble::tibble(!!var := val)
?`:=`
rbind3 <- function(...)
{
dots <- list(...)
rdf <- purrr::map_df(dots, rbind)
}
rbind3(dfs)
rbind3 <- function(...)
{
dots <- list(...)
rdf <- purrr::map_df(dots, rbind)
rdf
}
rbind3(dfs)
rbind2(dfs)
dplyr::bind_rows(dfs)
dplyr::bind_rows(!!!dfs)
dfs
enexprs(!!!dfs)
exprs(!!!dfs)
dfs
exprs(!!!dfs) == dfs
`:=`
?a
?abort
debugonce(`:=`)
var <- "x"
val <- c(1, 2, 3)
tibble::tibble(!!var := val)
library(rlang)
library
View(library)
set_attr <- function(.x, ...) {
attr <- rlang::list2(...)
attributes(.x) <- attr
.x
}
attrs <- list(x = 1, y = 2)
attr_name <- "z"
1:10 %>%
set_attr(w = 0, !!!attrs, !!attr_name := 3) %>%
str()
library(tidyverse)
set_attr <- function(.x, ...)
{
attr <- rlang::list2(...)
attributes(.x) <- attr
.x
}
attrs <- list(x = 1, y = 2)
attr_name <- "z"
1:10 %>%
set_attr(w = 0, !!!attrs, !!attr_name := 3) %>%
str()
1:10 %>%
set_attr(w = 0, attrs, !!attr_name := 3) %>%
str()
debugonce(set_attr)
1:10 %>%
set_attr(w = 0, attrs, !!attr_name := 3) %>%
str()
attr
debugonce(set_attr)
1:10 %>%
set_attr(w = 0, attrs, !!attr_name := 3) %>%
str()
attr()
attr
1:10 %>%
set_attr(w = 0, !!!attrs, !!attr_name := 3) %>%
str()
debugonce(set_attr)
1:10 %>%
set_attr(w = 0, !!!attrs, !!attr_name := 3) %>%
str()
attr
str(attr)
set_attr <- function(.x, ...)
{
attr <- list(...)
attributes(.x) <- attr
.x
}
attrs <- list(x = 1, y = 2)
attr_name <- "z"
1:10 %>% set_attr(attrs)
1:10 %>% set_attr(w = 10)
set_attr <- function(.x, ...)
{
attr <- rlang::list2(...)
attributes(.x) <- attr
.x
}
attrs <- list(x = 1, y = 2)
attr_name <- "z"
1:10 %>%
set_attr(w = 0, !!!attrs, !!attr_name := 3) %>%
str()
## compare with
set_attr <- function(.x, ...)
{
attr <- list(...)
attributes(.x) <- attr
.x
}
1:10 %>%
set_attr(w = 0, attrs)
1:10 %>%
set_attr(w = 0)
1:10 %>%
set_attr(w = 0) %>%   ## owrks
set_attr(attrs)
?`!!!`
?`...`
?rlang::`dyn-dots`
1:10 %>%
set_attr(w = 0) %>%   ## owrks
# set_attr(attrs)  ## Error... : attributes must be named!
set_attr(!!attr_name := 3)
1:10 %>%
set_attr(w = 0) %>%   ## owrks
# set_attr(attrs)  ## Error... : attributes must be named!
set_attr(!!attr_name = 3)
## use rlang::exec() if you want to use this technique with a function that does
## not have tidy dots
exec("mean", x= 10, na.rm = TRUE)
## use rlang::exec() if you want to use this technique with a function that does
## not have tidy dots
exec("mean", x = 1:10, na.rm = TRUE)
## ... (dot-dot-dot)
## read again 19 Quasiquotation Outline
dfs <- list(
a = data.frame(x = 1, y = 2),
b = data.frame(x = 3, y = 4)
)
## base R
## do.call
do.call("rbind", dfs)
f <- function(...) {
dots <- list(...)
if (length(dots) == 1 && is.list(dots[[1]])) {
dots <- dots[[1]]
}
dots
}
f(list(a = 1, b = 2))
f(a = 1, b = 2)
f <- function(...) {
dots <- list(...)
if (length(dots) == 1 && is.list(dots[[1]])) {
dots <- dots[[1]]
}
...
}
f(a = 1, b = 2)
f <- function(...) {
dots <- list(...)
if (length(dots) == 1 && is.list(dots[[1]])) {
dots <- dots[[1]]
}
...
}
f(list(a = 1, b = 2))
?interaction
a <- gl(2, 4, 8)
b <- gl(2, 2, 8, labels = c("ctrl", "treat"))
interaction(a, b)
?gl
a
View(interaction)
for (i in narg:1L) {
print(i)
}
narg <- 10
for (i in narg:1L) {
print(i)
}
RCurl::getURL
install.packages("RCurl")
View(library)
?RCurl::getURL
RCurl::getURL
getURI
RCurl::getURI
help(package = "RCurl")
txt = getURL("http://www.omegahat.net/RCurl/")
txt = RCurl::getURL("http://www.omegahat.net/RCurl/")
txt
debugonce(RCurl::getURL)
txt = RCurl::getURL("http://www.omegahat.net/RCurl/")
str(write)
class(write)
sloop::ftype(write)
sloop::otype(write)
write$update()
is.list(write)
myObject_methods <- list(
can_swim = function(self, can = TRUE)
{
cat(glue::glue("{self$name} can swim\n"))
}
)
myObject <- list(
new = function(name, ...)
{
dots <- list(name = name, ...)
myobject <- append(dots, myObject_methods)
class(myobject) <- "myObject"
}
)
mo <- myObject$new("blobb")
mo$can_swim()
myObject <- list(
new = function(name, ...)
{
dots <- list(name = name, ...)
myobject <- append(dots, myObject_methods)
class(myobject) <- "myObject"
return(myobject)
}
)
mo <- myObject$new("blobb")
mo$can_swim()
myObject_methods <- list(
can_swim = function(self, can = TRUE)
{
cat(glue::glue("{self$name} can swim\n"))
}
)
myObject <- list(
new = function(name, ...)
{
dots <- list(name = name, ...)
self <- list(self = dots)
myobject <- appen(self, myObject_methods)
class(myobject) <- "myObject"
return(myobject)
}
)
mo <- myObject$new("blobb")
myObject_methods <- list(
can_swim = function(self, can = TRUE)
{
cat(glue::glue("{self$name} can swim\n"))
}
)
myObject <- list(
new = function(name, ...)
{
dots <- list(name = name, ...)
self <- list(self = dots)
myobject <- append(self, myObject_methods)
class(myobject) <- "myObject"
return(myobject)
}
)
mo <- myObject$new("blobb")
mo
myObject <- list(
new = function(name, ...)
{
dots <- list(name = name, ...)
myobject <- append(dots, myObject_methods)
class(myobject) <- "myObject"
return(myobject)
}
)
mo <- myObject$new("blobb")
mo
myObject <- list(
new = function(name, ...)
{
dots <- list(name = name, ...)
myobject <- append(self = dots, myObject_methods)
class(myobject) <- "myObject"
return(myobject)
}
)
mo <- myObject$new("blobb")
myObject <- list(
new = function(name, ...)
{
dots <- list(self = list(name = name, ...))
myobject <- append(dots, myObject_methods)
class(myobject) <- "myObject"
return(myobject)
}
)
mo <- myObject$new("blobb")
mo
mo$self
myObject <- list(
new = function(name, ...)
{
dots <- list(name = name, ...)
myobject <- append(dots, myObject_methods)
class(myobject) <- "myObject"
return(myobject)
}
)
mo <- myObject$new("blobb")
mo
mo$name
