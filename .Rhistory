decorate(rstudioapi::getActiveDocumentContext()$path)
}
`_@_` <- make_command(`@`)
decorator <- function(f)
{
force(f)
wrapper <- function(...)
{
cat("Hello from decorator\n")
f(...)
}
return(wrapper)
}
`_@_`
?rev
decorate <- function(file)
{
if (!file.exists(file)) {
stop("file \"", file, "\" does not exist", call. = FALSE)
}
src <- new.env()
tryCatch(source(file = file, local = src, keep.source = FALSE),
error = function(e) {
stop("problem sourcing ", file, ", ", e$message,
call. = FALSE)
})
fileitr <- tinsel:::file_itr(file)
decor <- NULL
while (fileitr$has_next()) {
line <- fileitr$get_line()
if (grepl("^\\s*_@_", line)) {
d <- gsub("_@_|\\s", "", line)
if (char_at(d, -1) != ")") {
d <- paste0(d, "()")
}
decor <- c(decor, d)
}
else if (grepl("^(?!\\s*_@)_*<-", line, perl = TRUE) &&
!is.null(decor)) {
f <- gsub("^\\s*|\\s*<-.*$", "", line)
if (!is.function(get0(f, src))) {
next
}
decor <- rev(decor)
as_text <- f
for (d in decor) {
split_at <- first_of(d, "(")
dname <- substr(d, 1, split_at - 1)
dargs <- substr(d, split_at + 1, nchar(d))
if (!grepl("^\\s*\\)\\s*$", dargs)) {
dargs <- paste(",", dargs)
}
if (!exists(dname, envir = src)) {
stop("no definition found for decorator `",
dname, "`", call. = FALSE)
}
as_text <- c(dname, "(", as_text, dargs)
}
text_call <- paste(as_text, collapse = "", sep = "")
feval <- tryCatch(eval(parse(text = text_call),
envir = src), error = function(e) {
message("Problem evaluating `", f, "`: ", e$message)
NULL
})
if (!is.null(feval)) {
class(feval) <- c("decorated", class(feval))
attr(feval, "decoratee") <- get0(f, src)
dnames <- vapply(decor, re_search, character(1),
"^\\s*[^(]+")
attr(feval, "decorators") <- set_names(lapply(dnames,
get0, src), dnames)
assign(f, feval, parent.frame())
}
decor <- NULL
}
else if (grepl("^\\s*$", line)) {
}
else {
decor <- NULL
}
}
}
decorator <- function(f)
{
force(f)
wrapper <- function(...)
{
cat("Hello from decorator\n")
f(...)
}
return(wrapper)
}
`_@_`
`_@_`decorator
`_@_` decorator
`_@_`
decorator
crazy_func()
ls x
ls
ls x
ls(x)
print <- make_command(print)
print "hello"
print hello
print <- make_command(print, x)
print "hello"
print
print
x
## Functionals
## take other functions as argument
randomise <- function(f) f(runif(1e3))
hist(runif(1e6))
randomise(mean)
randomise(mean)
randomise(mean)
help(package = "rlang")
rlang::eval_tidy
## code is data
rlang::expr(mean(x, na.rm = TRUE))
## code is data
rlang::expr(mean(x, na.rm = TRUE)) -> test
class(test)
rlang::expr(x <- 1) -> test
class(test)
rlang::expr(1 + 1) -> test
class(test)
rlang::expr(x) -> test
class(test)
typeof(test)
rlang::expr(1 + 1) -> test
typeof(test)
rlang::enexpr
?rlang::enexpr
capture_it <- function(x)
{
rlang::enexpr(x)
}
capture_it(a + b + c)
capture_it <- function(x)
{
rlang::expr(x)
}
capture_it(a + b + c)
capture_it <- function(x)
{
rlang::enexpr(x)
}
capture_it(a + b + c)
## code is a tree
## almost any programming language -> abstract syntax tree (AST)
## R is unusual in that you can actually inspect and manipulate this tree
lobstr::ast(f(a, "b"))
?lobstr::ast
lobstr::ast
str(f(a, "b"))
str(expr(f(a, "b")))
str(rlang::expr(f(a, "b")))
rlang::expr(f(a, "b"))
## code is a tree
## almost any programming language -> abstract syntax tree (AST)
## R is unusual in that you can actually inspect and manipulate this tree
lobstr::ast(f(a, "b"))
lobstr::ast(1 + 2 * 3)
## code can generate code
## code to create new trees
rlang::call2("f", 1, 2, 3) ==
rlang::expr(f(1, 2, 3))
?rlang::call2
rlang::call2(x <- 1)
rlang::call2(f, 1, 2, 3)
rlang::call2("<-", x, y)
rlang::call2("<-", "x", "y")
y <- 10
rlang::call2("<-", "x", "y") %>% eval()
eval(rlang::call2("<-", "x", "y"))
x
eval(rlang::call2("<-", "x", y))
x
?`!!`
## run code
## needs expression and environment, which tells R what the symbols in the
## expression mean
base::eval(expr(x + y), env(x = 1, y = 10))
library(rlang)
## run code
## needs expression and environment, which tells R what the symbols in the
## expression mean
base::eval(expr(x + y), env(x = 1, y = 10))
## !!x inserts the code tree in x into the expression, i.e. inserts expression into other expression
## building complex trees with help of simpler trees
xx <- expr(x + x)
yy <- expr(y + y)
expr(!!xx / !!yy)
## customising evaluation with functions
## override the behaviour of existing functions in an encapsulated way...
string_math <- function(x)
{
e <- env(
rlang::caller_env(),
`@` = function(x, y) paste0(x, y),
`*` = function(x, y) strrep(x, y)
)
eval(enexpr(x), e)
}
name <- "Daniel"
string_math("Hello " @ name)
?rlang::caller_env
string_math(("x" * 2 + "-y") * 3)
string_math(("x" * 2 @ "-y") * 3)
string_math(("x" * 2 @ "-y") * 3)
## customising evaluation with functions
## override the behaviour of existing functions in an encapsulated way...
string_math <- function(x)
{
e <- env(
rlang::caller_env(),
`@` = function(x, y) paste0(x, y),  ## originally +
`*` = function(x, y) strrep(x, y)
)
eval(enexpr(x), e)
}
name <- "Daniel"
string_math("Hello " @ name)  ## wow! -> could be used for likelihood(...) and inside likelihood call stuff like random_coef(...)
string_math(("x" * 2 @ "-y") * 3)
## customising evaluation with functions
## override the behaviour of existing functions in an encapsulated way...
string_math <- function(x)
{
e <- env(
rlang::caller_env(),
`"` = function(x, y) paste0(x, y),  ## originally +
`*` = function(x, y) strrep(x, y)
)
eval(enexpr(x), e)
}
name <- "Daniel"
## customising evaluation with functions
## override the behaviour of existing functions in an encapsulated way...
string_math <- function(x)
{
e <- env(
rlang::caller_env(),
`.` = function(x, y) paste0(x, y),  ## originally +
`*` = function(x, y) strrep(x, y)
)
eval(enexpr(x), e)
}
name <- "Daniel"
string_math("Hello " . name)  ## wow! -> could be used for likelihood(...) and inside likelihood call stuff like random_coef(...)
## customising evaluation with functions
## override the behaviour of existing functions in an encapsulated way...
string_math <- function(x)
{
e <- env(
rlang::caller_env(),
`(` = function(x, y) paste0(x, y),  ## originally +
`*` = function(x, y) strrep(x, y)
)
eval(enexpr(x), e)
}
name <- "Daniel"
string_math("Hello " ( name)  ## wow! -> could be used for likelihood(...) and inside likelihood call stuff like random_coef(...)
## customising evaluation with functions
## override the behaviour of existing functions in an encapsulated way...
string_math <- function(x)
{
e <- env(
rlang::caller_env(),
`!` = function(x, y) paste0(x, y),  ## originally +
`*` = function(x, y) strrep(x, y)
)
eval(enexpr(x), e)
}
string_math("Hello " ! name)  ## wow! -> could be used for likelihood(...) and inside likelihood call stuff like random_coef(...)
## customising evaluation with functions
## override the behaviour of existing functions in an encapsulated way...
string_math <- function(x)
{
e <- env(
rlang::caller_env(),
`@` = function(x, y) paste0(x, y),  ## originally +
`*` = function(x, y) strrep(x, y)
)
eval(enexpr(x), e)
}
name <- "Daniel"
string_math("Hello " @ name)  ## wow! -> could be used for likelihood(...) and inside likelihood call stuff like random_coef(...)
## customising evaluation with functions
## override the behaviour of existing functions in an encapsulated way...
string_math <- function(x)
{
e <- env(
rlang::caller_env(),
`+` = function(x, y) paste0(x, y),  ## originally +
`*` = function(x, y) strrep(x, y)
)
eval(enexpr(x), e)
}
name <- "Daniel"
string_math(("x" * 2 + "-y") * 3)
## customizing evaluation with data
df <- data.frame(x = 1:5, y = sample(5))
eval(expr(x + y), df) ## some pitfalls
rlang::eval_tidy(expr(x + y), df)
## wrap up in function
with2 <- function(df, expr) {
eval_tidy(enexpr(expr), df)
}
with2(df, x + y)
z <- rlang::expr(y <- x * 10)
z
## parsing and deparsing
x <- 10
x1 <- "y <- x + 10"
x1
x2 <- rlang::parse_expr(x1)
x2
eval(x2)
x1 <- "y <- 'x' + 10"
x1
x2 <- rlang::parse_expr(x1)
x2
eval(x2)
x2
## walking AST with recursive functions
expr_type <- function(x)
{
if (rlang::is_syntactic_literal(x))
{
"constant"
}
else if (is.symbol(x))
{
"symbol"
}
else if (is.call(x))
{
"call"
}
else if (is.pairlist(x))
{
"pairlist"
}
else
{
typeof(x)
}
}
expr_type(expr("a"))
expr_type(expr(x))
expr_type(expr(f(1, 2)))
?is_call
l <- list("hello", "world")
l
c(l)
as.vector(l)
as.vector(l, mode = "vector")
?as.vector
as.vector(l, mode = "character")
as.vector(l, mode = "character") -> test
purrr::map(elems, rlang::as_string) %>%
as.vector(mode = "numeric")
devtools::load_all()
devtools::load_all()
devtools::load_all()
packageVersion("pkgload")
install.packages("pkgload")
install.packages("pkgload")
install.packages("pkgload")
install.packages("pkgload")
packageVersion("pkgload")
devtools::load_all()
devtools::install_version("pkgload", version = "1.2.4")
devtools::load_all()
packageVersion("pkgload")
devtools::load_all()
decoratoR::foo()
## motivation
ccement <- function(...)
{
elems <- rlang::ensyms(...)
purrr::map(elems, rlang::as_string) %>%
as.vector(mode = "character")
}
ccement(hello,
world,
how,
is,
it)
ccement(hello,
world,
how,
is,
it,
going)
?cc
?rlang::as_string
?`!!`
x <- "hello"
rlang::is_expression(x)
x <- "hello"
rlang::is_symbol(x)
rlang::is_expression(x)
rlang::is_call(x)
rlang::is_expression(!!x)
y <- rlang::expr(hello, x)
y <- rlang::expr(paste("hello", x))
eval(y)
y <- rlang::expr(paste("hello", !!x))
## quoting
## capturing an expression without evaluating it
## there are 4 important quoting functions:
## expr() captures its argument exactly as provided (without whitespace and comments)
## however:
f1 <- function(x) expr(x)
f1(a + b + c)
## quoting
## capturing an expression without evaluating it
## there are 4 important quoting functions:
## expr() captures its argument exactly as provided (without whitespace and comments)
## however:
f1 <- function(x) rlang::expr(x)
f1(a + b + c)
## 3. enexprs() capture all arguments in ...
f <- function(...) rlang::enexprs(...)
## 3. enexprs() capture all arguments in ...
f <- function(...) rlang::enexprs(...)
## 3. enexprs() capture all arguments in ...
f <- function(...) rlang::enexprs(...)
f(x = 1, y = 2, z = x * y)
test <- f(x = 1, y = 2, z = x * y)
rlang::is_expression(test$z)
## 4. exprs() make a list of expressions
## useful interactively...
exprs(x = x ^ 2, y = y ^ 3, z ?? .)
## 4. exprs() make a list of expressions
## useful interactively...
rlang::exprs(x = x ^ 2, y = y ^ 3, z ?? .)
## capturing symbols
## if you want to allow the user to specify a variable name (symbol) and not
## an arbitrary expression (although symbols are expressions...)
rlang::ensym(x + y)
rlang::esyms(x, y, z)
rlang::ensyms(x, y, z)
rm(list = ls())
## capturing symbols
## if you want to allow the user to specify a variable name (symbol) and not
## an arbitrary expression (although symbols are expressions...)
rlang::ensym(x)
## capturing symbols
## if you want to allow the user to specify a variable name (symbol) and not
## an arbitrary expression (although symbols are expressions...)
x <- y <- z <- 1
rlang::ensym(x)
rlang::ensym(x + y)  #> throws an error
rlang::ensyms(x, y, z)
## capturing symbols
## if you want to allow the user to specify a variable name (symbol) and not
## an arbitrary expression (although symbols are expressions...)
x <- 1
rlang::ensym(x)
## capturing symbols
## if you want to allow the user to specify a variable name (symbol) and not
## an arbitrary expression (although symbols are expressions...)
rlang::ensym(expr(x))
## capturing symbols
## if you want to allow the user to specify a variable name (symbol) and not
## an arbitrary expression (although symbols are expressions...)
rlang::ensym(rlang::sym(x))
## capturing symbols
## if you want to allow the user to specify a variable name (symbol) and not
## an arbitrary expression (although symbols are expressions...)
rlang::ensym(rlang::expr(x))
## capturing symbols
## if you want to allow the user to specify a variable name (symbol) and not
## an arbitrary expression (although symbols are expressions...)
x <- rlang::expr(x)
rlang::ensym()
rlang::ensym(x)
rlang::ensym("x")
## capturing symbols
## if you want to allow the user to specify a variable name (symbol) and not
## an arbitrary expression (although symbols are expressions...)
x <- rlang::sym(x)
rlang::ensym(x)
?`~`
y ~ x + z
y ~ x + z -> test
test
?call
call(test, x = 1, z = 2)
call("test", x = 1, z = 2)
?eval
## further (but discussed later):
## bquote() -> form of quasiquotation
## ~ formula -> quoting function that also captures the environment
## @daniehei example
f <- function(formula, ...)
{
args <- rlang::enexprs(...)
e <- new.env()
eval(args, e)
eval(formula, e)
return(e)
}
test <- f(z ~ x + y, x = 1, y = 2)
test$z
ls(test)
ls(envir = test)
test$x
